#! /bin/python3
# Author: Rodrigo Valle
#
# TODO:
# - netctl supports hashes of passwords, so use those instead of storing
#   passords plaintext
#
# NOTES:
# - for use with netctl
# - only supports open networks (for now)

import sys, os
import getpass
import optparse
import subprocess

# set some defaults
profile_dir   = "/etc/netctl"
net_interface = "wlp2s0"
usage = "usage: %prog [-h] [-p] SSID PROFILE"

class NetctlProfile(object):
    @staticmethod
    def parse_conf(fileobj):
        '''
        returns a NetctlProfile initialized from an existing config file
        '''
        raise NotImplementedError

    def __init__(self, ssid, hidden, profile_name, interface, description,
                 password=None, security=None):
        self.ssid = ssid
        self.hidden = hidden
        self.name = profile_name.replace("'", "")
        self.iface = interface.replace("'", "")
        self.desc = description.replace("'", "")
        self.directory = profile_dir
        self.security = security
        self.password = password


    def _get_psk(self):
        wpa_passphrase = subprocess.Popen(["wpa_passphrase", self.ssid], stdin=subprocess.PIPE)
        wpa_passphrase.communicate(input=self.password + '\n')
        print(psk.stdout)


    def make_config(self):
        '''
        returns a netctl configuration file as an array of lines
        use file.writelines() to write to a configuration file
        '''
        conf = [
            "# generated by ~/scripts/add_wifi\n\n",
            "Description='{}'\n".format(self.desc),
            "Interface='{}'\n".format(self.iface),
            "Connection=wireless\n\n",
            "IP=dhcp\n\n",
            "ESSID='{}'\n".format(self.ssid)
        ]

        if self.hidden:
            conf.append("Hidden=yes\n")

        if self.security:
            conf.append("Security={}\n".format(self.security))

        if self.password:
            conf.append("Key={}".format(self._get_psk()))

        return conf


def chk_root():
    if os.geteuid() != 0:
        print("This script requires root permissions, using sudo...",
              file=sys.stderr)
        os.execlp('sudo', sys.executable, *sys.argv)


def chk_exist(path):
    if os.path.isfile(path):
        print("A profile with that name already exits.")
        sys.exit(1)


def prompt_net_info():
    password = getpass.getpass(prompt="Enter network password: ")
    valid = { 'y':   True,
              'yes': True,
              'n':   False,
              'no':  False  }

    ans = input("Is this a hidden SSID? [y/N] ").lower()
    hidden = False

    while True:
        if ans in valid:
            hidden = valid[ans]
            break
        elif ans == "":
            break
        else:
            ans = input("Please type 'y' or 'n'")

    description = input("Enter a short description: ")
    return (password, hidden, description)


def handle_args():
    #help_opt = ["-h", "--help"]
    #if len(sys.argv) != 3 or sys.argv[1] in help_opt:
    #    print(usage.format(sys.argv[0]), file=sys.stderr)
    #    sys.exit(1)
    parser = optparse.OptionParser(usage=usage)
    parser.add_option(
        '-p', '--password',
        help='set network password',
        action='store_true', dest='getpass',
        default=False
    )
    parser.add_option(
        '-d', '--directory', metavar='PATH',
        help='set the netctl profile directory',
        action='store', type='string', dest='dir',
        default=profile_dir
    )

    (options, args) = parser.parse_args()
    if len(args) != 2:
        parser.error("wrong number of arguments")
    return (options, args)


def main():
    chk_root()

    (opts, args) = handle_args()
    ssid = args[0]
    profile_name = args[1]

    full_path = opts.dir + '/' + profile_name
    chk_exist(full_path)

    (password, net_hidden, net_desc) = prompt_net_info()

    profile = NetctlProfile(ssid, net_hidden, profile_name, net_interface,
                            net_desc, password=password, security='wpa')
    conf = profile.make_config()

    try:
        f = open(self.path, mode='w')
        f.writelines(conf)
    except IOError:
        print("couldn't create configuration file", file=sys.stderr)
        sys.exit(1)
    finally:
        f.close()



if __name__ == "__main__":
    main()
